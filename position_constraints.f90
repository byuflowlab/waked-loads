subroutine constraints_position(nTurbines, nBoundaries, turbineX, turbineY, boundaryVertices, &
                                &boundaryNormals, separation_squared, boundaryDistances)

    ! define precision to be the standard for a double precision ! on local system
    integer, parameter :: dp = kind(0.d0)
    ! in
    integer, intent(in) :: nTurbines, nBoundaries
    real(dp), dimension(nTurbines), intent(in) :: turbineX, turbineY
    real(dp), dimension(nBoundaries,2), intent(in) :: boundaryVertices, boundaryNormals
    !out
    real(dp), dimension(nTurbines,nBoundaries), intent(out) :: boundaryDistances
    real(dp), dimension((nTurbines-1)*nTurbines/2), intent(out) :: separation_squared

    call turbine_spacing_squared(nTurbines, turbineX, turbineY, separation_squared)
    call boundary_distances(nTurbines, nBoundaries, turbineX, turbineY, boundaryVertices, &
                            &boundaryNormals, boundaryDistances)
    end subroutine constraints_position


subroutine turbine_spacing_squared(nTurbines, turbineX, turbineY, separation_squared)

    implicit none

    ! define precision to be the standard for a double precision ! on local system
    integer, parameter :: dp = kind(0.d0)
    ! in
    integer, intent(in) :: nTurbines
    real(dp), dimension(nTurbines), intent(in) :: turbineX, turbineY
    ! out
    real(dp), dimension((nTurbines-1)*nTurbines/2), intent(out) :: separation_squared
    ! local
    integer :: i, j, k
    k = 1
    do i = 1, nTurbines
        do j = i+1, nTurbines
            separation_squared(k)= (turbineX(j)-turbineX(i))**2+(turbineY(j)-turbineY(i))**2
            k = k+1
        end do
    end do

end subroutine turbine_spacing_squared



subroutine boundary_distances(nTurbines, nBoundaries, turbineX, turbineY, boundaryVertices, boundaryNormals, boundaryDistances)

    implicit none

    ! define precision to be the standard for a double precision ! on local system
    integer, parameter :: dp = kind(0.d0)
    ! in
    integer, intent(in) :: nTurbines, nBoundaries
    real(dp), dimension(nTurbines), intent(in) :: turbineX, turbineY
    real(dp), dimension(nBoundaries,2), intent(in) :: boundaryVertices, boundaryNormals
    !out
    real(dp), dimension(nTurbines,nBoundaries), intent(out) :: boundaryDistances
    !local
    REAL(dp), PARAMETER :: pi=3.141592653589793_dp
    integer :: i, j
    real(dp) :: R
    real(dp), dimension(2) :: pa, d_vec

    if (nBoundaries .eq. 1) then
        do i = 1, nTurbines
            R = sqrt((turbineX(i)-boundaryNormals(1,1))**2+(turbineY(i)-boundaryNormals(1,2))**2)
            boundaryDistances(i,1) = boundaryVertices(1,1)-R
        end do
    else
        do i = 1, nTurbines
            do j = 1, nBoundaries
              pa(1) = boundaryVertices(j, 1)-turbineX(i)
              pa(2) = boundaryVertices(j, 2)-turbineY(i)
              ! d_vec = dot_product(pa,boundaryNormals(j))*boundaryNormals(j)
              d_vec(1) = (pa(1)*boundaryNormals(j, 1)+pa(2)*boundaryNormals(j, 2))*boundaryNormals(j, 1)
              d_vec(2) = (pa(1)*boundaryNormals(j, 1)+pa(2)*boundaryNormals(j, 2))*boundaryNormals(j, 2)
              ! boundaryDistances(i, j) = dot_product(d_vec, boundaryNormals(j))
              boundaryDistances(i, j) = d_vec(1)*boundaryNormals(j, 1)+d_vec(2)*boundaryNormals(j, 2)
            end do
        end do
    end if

end subroutine boundary_distances






!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:31
!
!  Differentiation of turbine_spacing_squared in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: separation_squared
!   with respect to varying inputs: turbinex turbiney
SUBROUTINE TURBINE_SPACING_SQUARED_DV(nturbines, turbinex, turbinexd, &
& turbiney, turbineyd, separation_squared, separation_squaredd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: turbinexd, &
& turbineyd
! out
  REAL(dp), DIMENSION((nturbines-1)*nturbines/2), INTENT(OUT) :: &
& separation_squared
  REAL(dp), DIMENSION(nbdirs, (nturbines-1)*nturbines/2), INTENT(OUT)&
& :: separation_squaredd
! local
  INTEGER :: i, j, k
  INTEGER :: nd
  INTEGER :: nbdirs
  k = 1
  separation_squaredd(:, :) = 0.0_8
  DO i=1,nturbines
    DO j=i+1,nturbines
      DO nd=1,nbdirs
        separation_squaredd(nd, k) = 2*(turbinex(j)-turbinex(i))*(&
&         turbinexd(nd, j)-turbinexd(nd, i)) + 2*(turbiney(j)-turbiney(i&
&         ))*(turbineyd(nd, j)-turbineyd(nd, i))
      END DO
      separation_squared(k) = (turbinex(j)-turbinex(i))**2 + (turbiney(j&
&       )-turbiney(i))**2
      k = k + 1
    END DO
  END DO
END SUBROUTINE TURBINE_SPACING_SQUARED_DV

!  Differentiation of boundary_distances in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: boundarydistances
!   with respect to varying inputs: turbinex turbiney
SUBROUTINE BOUNDARY_DISTANCES_DV(nturbines, nboundaries, turbinex, &
& turbinexd, turbiney, turbineyd, boundaryvertices, boundarynormals, &
& boundarydistances, boundarydistancesd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nboundaries
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: turbinexd, &
& turbineyd
  REAL(dp), DIMENSION(nboundaries, 2), INTENT(IN) :: boundaryvertices, &
& boundarynormals
!out
  REAL(dp), DIMENSION(nturbines, nboundaries), INTENT(OUT) :: &
& boundarydistances
  REAL(dp), DIMENSION(nbdirs, nturbines, nboundaries), INTENT(OUT) ::&
& boundarydistancesd
!local
  REAL(dp), PARAMETER :: pi=3.141592653589793_dp
  INTEGER :: i, j
  REAL(dp) :: r
  REAL(dp), DIMENSION(nbdirs) :: rd
  REAL(dp), DIMENSION(2) :: pa, d_vec
  REAL(dp), DIMENSION(nbdirs, 2) :: pad, d_vecd
  INTRINSIC SQRT
  REAL(dp) :: arg1
  REAL(dp), DIMENSION(nbdirs) :: arg1d
  INTEGER :: nd
  INTEGER :: nbdirs
  IF (nboundaries .EQ. 1) THEN
    boundarydistancesd(:, :, :) = 0.0_8
    DO i=1,nturbines
      arg1 = (turbinex(i)-boundarynormals(1, 1))**2 + (turbiney(i)-&
&       boundarynormals(1, 2))**2
      DO nd=1,nbdirs
        arg1d(nd) = 2*(turbinex(i)-boundarynormals(1, 1))*turbinexd(nd, &
&         i) + 2*(turbiney(i)-boundarynormals(1, 2))*turbineyd(nd, i)
        IF (arg1 .EQ. 0.0) THEN
          rd(nd) = 0.0_8
        ELSE
          rd(nd) = arg1d(nd)/(2.0*SQRT(arg1))
        END IF
        boundarydistancesd(nd, i, 1) = -rd(nd)
      END DO
      r = SQRT(arg1)
      boundarydistances(i, 1) = boundaryvertices(1, 1) - r
    END DO
  ELSE
    boundarydistancesd(:, :, :) = 0.0_8
    pad(:, :) = 0.0_8
    d_vecd(:, :) = 0.0_8
    DO i=1,nturbines
      DO j=1,nboundaries
        DO nd=1,nbdirs
          pad(nd, 1) = -turbinexd(nd, i)
          pad(nd, 2) = -turbineyd(nd, i)
! d_vec = dot_product(pa,boundaryNormals(j))*boundaryNormals(j)
          d_vecd(nd, 1) = boundarynormals(j, 1)*(boundarynormals(j, 1)*&
&           pad(nd, 1)+boundarynormals(j, 2)*pad(nd, 2))
          d_vecd(nd, 2) = boundarynormals(j, 2)*(boundarynormals(j, 1)*&
&           pad(nd, 1)+boundarynormals(j, 2)*pad(nd, 2))
! boundaryDistances(i, j) = dot_product(d_vec, boundaryNormals(j))
          boundarydistancesd(nd, i, j) = boundarynormals(j, 1)*d_vecd(nd&
&           , 1) + boundarynormals(j, 2)*d_vecd(nd, 2)
        END DO
        pa(1) = boundaryvertices(j, 1) - turbinex(i)
        pa(2) = boundaryvertices(j, 2) - turbiney(i)
        d_vec(1) = (pa(1)*boundarynormals(j, 1)+pa(2)*boundarynormals(j&
&         , 2))*boundarynormals(j, 1)
        d_vec(2) = (pa(1)*boundarynormals(j, 1)+pa(2)*boundarynormals(j&
&         , 2))*boundarynormals(j, 2)
        boundarydistances(i, j) = d_vec(1)*boundarynormals(j, 1) + d_vec&
&         (2)*boundarynormals(j, 2)
      END DO
    END DO
  END IF
END SUBROUTINE BOUNDARY_DISTANCES_DV

!  Differentiation of constraints_position in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: separation_squared boundarydistances
!   with respect to varying inputs: turbinex turbiney
!   RW status of diff variables: turbinex:in turbiney:in separation_squared:out
!                boundarydistances:out
SUBROUTINE CONSTRAINTS_POSITION_DV(nturbines, nboundaries, turbinex, &
& turbinexd, turbiney, turbineyd, boundaryvertices, boundarynormals, &
& separation_squared, separation_squaredd, boundarydistances, &
& boundarydistancesd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nturbines, nboundaries
  REAL(dp), DIMENSION(nturbines), INTENT(IN) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(IN) :: turbinexd, &
& turbineyd
  REAL(dp), DIMENSION(nboundaries, 2), INTENT(IN) :: boundaryvertices, &
& boundarynormals
!out
  REAL(dp), DIMENSION(nturbines, nboundaries), INTENT(OUT) :: &
& boundarydistances
  REAL(dp), DIMENSION(nbdirs, nturbines, nboundaries), INTENT(OUT) ::&
& boundarydistancesd
  REAL(dp), DIMENSION((nturbines-1)*nturbines/2), INTENT(OUT) :: &
& separation_squared
  REAL(dp), DIMENSION(nbdirs, (nturbines-1)*nturbines/2), INTENT(OUT)&
& :: separation_squaredd
  INTEGER :: nbdirs
  CALL TURBINE_SPACING_SQUARED_DV(nturbines, turbinex, turbinexd, &
&                           turbiney, turbineyd, separation_squared, &
&                           separation_squaredd, nbdirs)
  CALL BOUNDARY_DISTANCES_DV(nturbines, nboundaries, turbinex, turbinexd&
&                      , turbiney, turbineyd, boundaryvertices, &
&                      boundarynormals, boundarydistances, &
&                      boundarydistancesd, nbdirs)
END SUBROUTINE CONSTRAINTS_POSITION_DV
